//bit of code from abner duel
//collect some other scope disable optionns to 
public Action CommandSemMira(int client, int args)
{
	if (NoScopeEnabled)
	{
		NoScopeEnabled = false;
		CPrintToChatAll("{green}%t\x01%t", "prefix", "Scope On");
		for (int i = 1; i <= MaxClients; i++)
		{
			if (IsValidClient(i) && IsPlayerAlive(i))
			{
				for (int j = 0; j < 5; j++)
				{
					int weapon = GetPlayerWeaponSlot(i, j);
					if (weapon == -1)
					{
						continue;
					}
					char item[128];
					GetEdictClassname(weapon, item, sizeof(item));
					if (isNoScopeWeapon(item))
					{
						SetEntDataFloat(weapon, m_flNextSecondaryAttack, 0.0);
					}
				}
			}
		}
		return Plugin_Handled;
	}
	else
	{
		NoScopeEnabled = true;
		CPrintToChatAll("{green}%t\x01%t", "prefix", "Scope Off");
		return Plugin_Handled;
	}
}



//bara noscope plugin
#pragma semicolon 1

#include <sourcemod>
#include <sdkhooks>

#pragma newdecls required

#define NOSCOPE_VERSION  "2.0.2"

ConVar g_cEnablePlugin = null;
ConVar g_cEnableOneShot = null;
ConVar g_cAllowGrenade = null;
ConVar g_cAllowWorld = null;
ConVar g_cAllowMelee = null;
ConVar g_cAllowedWeapons = null;

int m_flNextSecondaryAttack = -1;

public Plugin myinfo = 
{
	name = "NoScope", 
	author = "Bara", 
	description = "", 
	version = NOSCOPE_VERSION, 
	url = "www.bara.in"
};

public void OnPluginStart()
{
	if (GetEngineVersion() != Engine_CSS && GetEngineVersion() != Engine_CSGO)
	{
		SetFailState("Only CSS and CSGO Support");
	}
	
	CreateConVar("noscope_version", NOSCOPE_VERSION, "NoScope", FCVAR_NOTIFY | FCVAR_DONTRECORD);
	
	g_cEnablePlugin = CreateConVar("noscope_enable", "1", "Enable / Disalbe NoScope Plugin", _, true, 0.0, true, 1.0);
	g_cEnableOneShot = CreateConVar("noscope_oneshot", "0", "Enable / Disable kill enemy with one shot", _, true, 0.0, true, 1.0);
	g_cAllowGrenade = CreateConVar("noscope_allow_grenade", "0", "Enable / Disalbe Grenade Damage", _, true, 0.0, true, 1.0);
	g_cAllowWorld = CreateConVar("noscope_allow_world", "0", "Enable / Disalbe World Damage", _, true, 0.0, true, 1.0);
	g_cAllowMelee = CreateConVar("noscope_allow_knife", "0", "Enable / Disalbe Knife Damage", _, true, 0.0, true, 1.0);
	g_cAllowedWeapons = CreateConVar("noscope_allow_weapons", "awp;scout", "What weapon should the player get back after it has zoomed?");
	
	g_cEnablePlugin.AddChangeHook(ChangeHook);
	
	AutoExecConfig();
	
	m_flNextSecondaryAttack = FindSendPropInfo("CBaseCombatWeapon", "m_flNextSecondaryAttack");
	
	for (int i = 1; i <= MaxClients; i++)
	{
		if (IsClientValid(i))
		{
			SDKHook(i, SDKHook_OnTakeDamage, OnTakeDamage);
			SDKHook(i, SDKHook_PreThink, OnPreThink);
		}
	}
}

public void OnClientPutInServer(int i)
{
	SDKHook(i, SDKHook_OnTakeDamage, OnTakeDamage);
	SDKHook(i, SDKHook_PreThink, OnPreThink);
}

public void ChangeHook(ConVar convar, const char[] oldValue, const char[] newValue)
{
	if(convar == g_cEnablePlugin)
	{
		if(view_as<bool>(StringToInt(newValue)) == false)
		{
			ResetScope();
		}
	}
}

public Action OnPreThink(int client)
{
	if (g_cEnablePlugin.BoolValue)
	{
		int iWeapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
		SetNoScope(iWeapon);
	}
	return Plugin_Continue;
}

public Action OnTakeDamage(int victim, int &attacker, int &inflictor, float &damage, int &damagetype, int &weapon, float damageForce[3], float damagePosition[3])
{
	if (g_cEnablePlugin.BoolValue)
	{
		if (IsClientValid(victim))
		{
			if (damagetype & DMG_FALL || attacker == 0)
			{
				if (g_cAllowWorld.BoolValue)
					return Plugin_Continue;
				else
					return Plugin_Handled;
			}

			if (IsClientValid(attacker))
			{
				char sGrenade[32];
				char sWeapon[32];
				
				GetEdictClassname(inflictor, sGrenade, sizeof(sGrenade));
				GetClientWeapon(attacker, sWeapon, sizeof(sWeapon));
				
				if ((StrContains(sWeapon, "knife", false) != -1) || (StrContains(sWeapon, "bayonet", false) != -1))
					if (g_cAllowMelee.BoolValue)
						return Plugin_Continue;
				
				if (StrContains(sGrenade, "_projectile", false) != -1)
					if (g_cAllowGrenade.BoolValue)
						return Plugin_Continue;
				
				char sBuffer[256], sWeapons[64][64];
				g_cAllowedWeapons.GetString(sBuffer, sizeof(sBuffer));
				
				int iCount = ExplodeString(sBuffer, ";", sWeapons, sizeof(sWeapons), sizeof(sWeapons[]));
				
				for (int i = 0; i < iCount; i++)
				{
					if (StrContains(sWeapon[7], sWeapons[i], false) != -1)
					{
						if (g_cEnableOneShot.BoolValue)
						{
							damage = float(GetClientHealth(victim) + GetClientArmor(victim));
							return Plugin_Changed;
						}
						return Plugin_Continue;
					}
				}
				return Plugin_Handled;
			}
		}
	}
	return Plugin_Continue;
}

stock void SetNoScope(int weapon)
{
	if (IsValidEdict(weapon))
	{
		char classname[MAX_NAME_LENGTH];
		GetEdictClassname(weapon, classname, sizeof(classname));
		
		if (StrEqual(classname[7], "ssg08") || StrEqual(classname[7], "aug") || StrEqual(classname[7], "sg550") || StrEqual(classname[7], "sg552") || StrEqual(classname[7], "sg556") || StrEqual(classname[7], "awp") || StrEqual(classname[7], "scar20") || StrEqual(classname[7], "g3sg1"))
			SetEntDataFloat(weapon, m_flNextSecondaryAttack, GetGameTime() + 2.0);
	}
}

void ResetScope()
{
	for (int i = 0; i <= MaxClients; i++)
	{
		if(IsClientValid(i) && IsPlayerAlive(i))
		{
			int weapon = GetEntPropEnt(i, Prop_Send, "m_hActiveWeapon");
			
			if (IsValidEdict(weapon))
			{
				char classname[MAX_NAME_LENGTH];
				GetEdictClassname(weapon, classname, sizeof(classname));
				
				if (StrEqual(classname[7], "ssg08") || StrEqual(classname[7], "aug") || StrEqual(classname[7], "sg550") || StrEqual(classname[7], "sg552") || StrEqual(classname[7], "sg556") || StrEqual(classname[7], "awp") || StrEqual(classname[7], "scar20") || StrEqual(classname[7], "g3sg1"))
					SetEntDataFloat(weapon, m_flNextSecondaryAttack, GetGameTime() - 0.1);
			}
		}
	}
}

stock bool IsClientValid(int client)
{
	if (client > 0 && client <= MaxClients && IsClientInGame(client))
		return true;
	return false;
}


//bara plus on ground command
#pragma semicolon 1

#include <sourcemod>
#include <sdkhooks>
#include <sdktools>
#include <autoexecconfig>
//#include <updater>

#define NOSCOPE_VERSION  "1.0.3.1"
#define UPDATE_URL    "https://bara.in/update/noscope.txt"

new Handle:g_hEnablePlugin = INVALID_HANDLE,
	Handle:g_hEnableOneShot = INVALID_HANDLE,
	Handle:g_hEnableWeapon = INVALID_HANDLE,
	Handle:g_hAllowGrenade = INVALID_HANDLE,
	Handle:g_hAllowWorld = INVALID_HANDLE,
	Handle:g_hAllowMelee = INVALID_HANDLE,
	Handle:g_hAllowedWeapon = INVALID_HANDLE,
	Handle:g_hAllowOnGround = INVALID_HANDLE;

new String:g_sAllowedWeapon[32],
	String:g_sGrenade[32],
	String:g_sWeapon[32];

new m_flNextSecondaryAttack;

public Plugin:myinfo =
{
	name = "NoScope (Jump Support)",
	author = "Bara, Jump support by Neuro Toxin",
	description = "",
	version = NOSCOPE_VERSION,
	url = "www.bara.in"
};

public OnPluginStart()
{
	if(GetEngineVersion() != Engine_CSS && GetEngineVersion() != Engine_CSGO)
	{
		SetFailState("Only CSS and CSGO Support");
	}

	//LoadTranslations("noscope.phrases"); <- no translations are in use

	AutoExecConfig_SetFile("plugin.noscope", "sourcemod");
	AutoExecConfig_SetCreateFile(true);

	CreateConVar("noscope_version", NOSCOPE_VERSION, "NoScope", FCVAR_NOTIFY|FCVAR_DONTRECORD);
	g_hEnablePlugin = AutoExecConfig_CreateConVar("noscope_enable", "1", "Enable / Disalbe NoScope Plugin", _, true, 0.0, true, 1.0);
	g_hEnableOneShot = AutoExecConfig_CreateConVar("noscope_oneshot", "0", "Enable / Disable kill enemy with one shot", _, true, 0.0, true, 1.0);
	g_hEnableWeapon = AutoExecConfig_CreateConVar("noscope_oneweapon", "1", "Enable / Disalbe Only One Weapon Damage", _, true, 0.0, true, 1.0);
	g_hAllowGrenade = AutoExecConfig_CreateConVar("noscope_allow_grenade", "0", "Enable / Disalbe Grenade Damage", _, true, 0.0, true, 1.0);
	g_hAllowWorld = AutoExecConfig_CreateConVar("noscope_allow_world", "0", "Enable / Disalbe World Damage", _, true, 0.0, true, 1.0);
	g_hAllowMelee = AutoExecConfig_CreateConVar("noscope_allow_knife", "0", "Enable / Disalbe Knife Damage", _, true, 0.0, true, 1.0);
	g_hAllowedWeapon = AutoExecConfig_CreateConVar("noscope_allow_weapon", "weapon_awp", "What weapon should the player get back after it has zoomed?");
	g_hAllowOnGround = AutoExecConfig_CreateConVar("noscope_allow_onground", "0", "Enable / Disable NoScope only when the player is jumping ");
	
	AutoExecConfig_ExecuteFile();
	AutoExecConfig_CleanFile();

	m_flNextSecondaryAttack = FindSendPropOffs("CBaseCombatWeapon", "m_flNextSecondaryAttack");

	for(new i = 1; i <= MaxClients; i++)
	{
		if(IsClientValid(i))
		{
			SDKHook(i, SDKHook_OnTakeDamage, OnTakeDamage);
			SDKHook(i, SDKHook_PreThink, OnPreThink);
		}
	}

	if (LibraryExists("updater"))
	{
		//Updater_AddPlugin(UPDATE_URL);
	}
}

public OnLibraryAdded(const String:name[])
{
	if (StrEqual(name, "updater"))
	{
		//Updater_AddPlugin(UPDATE_URL);
	}
}

public OnClientPutInServer(i)
{
	SDKHook(i, SDKHook_OnTakeDamage, OnTakeDamage);
	SDKHook(i, SDKHook_PreThink, OnPreThink);
}

public Action:OnPreThink(client)
{
	new iWeapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
	SetNoScope(client, iWeapon);
	return Plugin_Continue;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	if(GetConVarInt(g_hEnablePlugin))
	{
		if(IsClientValid(victim))
		{
			if(damagetype & DMG_FALL || attacker == 0)
			{
				if(GetConVarInt(g_hAllowWorld))
				{
					return Plugin_Continue;
				}
				else
				{
					return Plugin_Handled;
				}
			}

			if(IsClientValid(attacker))
			{
				GetEdictClassname(inflictor, g_sGrenade, sizeof(g_sGrenade));
				GetClientWeapon(attacker, g_sWeapon, sizeof(g_sWeapon));

				if(GetConVarInt(g_hEnableWeapon))
				{
					GetConVarString(g_hAllowedWeapon, g_sAllowedWeapon, sizeof(g_sAllowedWeapon));

					if(!StrEqual(g_sWeapon[7], g_sAllowedWeapon))
					{
						return Plugin_Handled;
					}
				}

				if(GetConVarInt(g_hEnableOneShot))
				{
					damage = float(GetClientHealth(victim));
					return Plugin_Changed;
				}

				if(GetConVarInt(g_hAllowMelee))
				{
					if(StrEqual(g_sWeapon, "weapon_knife"))
					{
						return Plugin_Continue;
					}
				}

				if(GetConVarInt(g_hAllowGrenade))
				{
					if(GetEngineVersion() == Engine_CSS)
					{
						if(StrEqual(g_sGrenade, "hegrenade_projectile"))
						{
							return Plugin_Continue;
						}
					}
					else if(GetEngineVersion() == Engine_CSGO)
					{
						if(StrEqual(g_sGrenade, "hegrenade_projectile") || StrEqual(g_sGrenade, "decoy_projectile") || StrEqual(g_sGrenade, "molotov_projectile"))
						{
							return Plugin_Continue;
						}
					}
				}
				return Plugin_Continue;
			}
			else
			{
				return Plugin_Handled;
			}
		}
		else
		{
			return Plugin_Handled;
		}
	}
	else
	{
		return Plugin_Continue;
	}
}

stock SetNoScope(client, weapon)
{
	if(IsValidEdict(weapon))
	{
		decl String:classname[MAX_NAME_LENGTH];

		if (GetEdictClassname(weapon, classname, sizeof(classname))
		|| StrEqual(classname[7], "ssg08")  || StrEqual(classname[7], "aug")
		|| StrEqual(classname[7], "sg550")  || StrEqual(classname[7], "sg552")
		|| StrEqual(classname[7], "sg556")  || StrEqual(classname[7], "awp")
		|| StrEqual(classname[7], "scar20") || StrEqual(classname[7], "g3sg1"))
		{
			if (GetConVarBool(g_hAllowOnGround))
			{
				if (!(GetEntityFlags(client) & FL_ONGROUND))
				{
					if (GetEntProp(client, Prop_Send, "m_bIsScoped"))
					{
						SetEntProp(weapon, Prop_Send, "m_zoomLevel", 0);
						SetEntProp(client, Prop_Send, "m_iFOV", 90);
						SetEntProp(client, Prop_Send, "m_bIsScoped", 0);
						SetEntProp(client, Prop_Send, "m_bResumeZoom", 0);
					}
					SetEntDataFloat(weapon, m_flNextSecondaryAttack, GetGameTime() + 0.1);
				}
			}
			else
				SetEntDataFloat(weapon, m_flNextSecondaryAttack, GetGameTime() + 0.1);
		}
	}
}

stock bool:IsClientValid(client)
{
	if(client > 0 && client <= MaxClients && IsClientInGame(client))
	{
		return true;
	}
	return false;
}
